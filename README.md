# 高频交易订单撮合系统设计文档

## 目录

1. [引言](#1-引言)
   - 1.1 [项目背景](#11-项目背景)
   - 1.2 [设计目标](#12-设计目标)
2. [系统架构设计](#2-系统架构设计)
   - 2.1 [总体架构](#21-总体架构)
   - 2.2 [模块交互流程](#22-模块交互流程)
3. [主要组件职责](#3-主要组件职责)
   - 3.1 [订单接收模块](#31-订单接收模块)
   - 3.2 [订单撮合引擎](#32-订单撮合引擎)
   - 3.3 [数据存储层](#33-数据存储层)
4. [挂单和吃单模块设计细节](#4-挂单和吃单模块设计细节)
   - 4.1 [订单数据结构](#41-订单数据结构)
   - 4.2 [限价单处理](#42-限价单处理)
   - 4.3 [市价单处理](#43-市价单处理)
   - 4.4 [Lua 脚本的使用](#44-lua-脚本的使用)
5. [数据处理与存储方案](#5-数据处理与存储方案)
   - 5.1 [Redis 数据结构](#51-redis-数据结构)
   - 5.2 [订单簿的存储](#52-订单簿的存储)
   - 5.3 [订单详情的存储](#53-订单详情的存储)
   - 5.4 [交易记录的存储](#54-交易记录的存储)
6. [高并发处理方法](#6-高并发处理方法)
   - 6.1 [原子性操作](#61-原子性操作)
   - 6.2 [Lua 脚本优化](#62-lua-脚本优化)
   - 6.3 [并发请求的处理](#63-并发请求的处理)
7. [使用案例](#7-使用案例)
   - 7.1 [限价单下单示例](#71-限价单下单示例)
   - 7.2 [市价单下单示例](#72-市价单下单示例)
   - 7.3 [系统测试与验证](#73-系统测试与验证)
8. [结论](#8-结论)

---

## 1. 引言

### 1.1 项目背景

在高频交易环境中，交易系统需要处理大量的实时订单，并以极低的延迟完成订单的撮合和执行。传统的内存撮合系统虽然速度快，但缺乏数据的持久化和高可用性保障。为了解决这些问题，我们引入了 Redis 作为数据存储层，利用其高性能和丰富的数据结构，实现高效且可靠的订单撮合系统。

### 1.2 设计目标

- **高性能**：支持高并发的订单请求，保证低延迟的订单处理。
- **高可用性**：通过 Redis 的持久化和高可用性特性，确保数据的可靠性。
- **数据一致性**：使用原子性操作，确保在高并发环境下的数据一致性。
- **可扩展性**：系统架构设计应支持未来的功能扩展和性能提升。

---

## 2. 系统架构设计

### 2.1 总体架构

系统主要由以下模块组成：

- **订单接收模块**：负责接收客户端的订单请求，并进行基本的验证和处理。
- **订单撮合引擎**：核心模块，负责订单的撮合逻辑，包括挂单和吃单的处理。
- **数据存储层（Redis）**：负责订单数据和交易记录的存储，提供高性能的数据读写能力。

### 2.2 模块交互流程

1. 客户端通过 HTTP 接口发送订单请求到订单接收模块。
2. 订单接收模块验证订单信息，并将订单传递给订单撮合引擎。
3. 订单撮合引擎与 Redis 交互，完成订单的存储、匹配和更新操作。
4. 交易完成后，系统将交易记录存储在 Redis 中，或异步写入持久化存储。

---

## 3. 主要组件职责

### 3.1 订单接收模块

**职责**：

- 接收并解析客户端发送的订单请求。
- 验证订单数据的完整性和合法性。
- 将订单信息传递给订单撮合引擎进行处理。

**设计细节**：

- 使用 `net/http` 包构建 HTTP 服务器，监听订单请求。
- 支持 JSON 格式的订单请求，方便客户端的集成。
- 提供异步处理机制，避免阻塞请求。

### 3.2 订单撮合引擎

**职责**：

- 实现订单的撮合逻辑，包括限价单和市价单的处理。
- 与 Redis 交互，进行订单数据的存储、查询和更新。
- 使用 Lua 脚本，保证在高并发环境下的原子性操作。

**设计细节**：

- 将订单撮合逻辑封装在 Lua 脚本中，避免网络延迟和数据不一致。
- 对于限价单，直接存储在订单簿中，等待匹配。
- 对于市价单，实时从订单簿中匹配最佳对手单，完成交易。

### 3.3 数据存储层

**职责**：

- 负责订单数据和交易记录的存储。
- 提供高性能的读写操作，支持高并发访问。
- 确保数据的持久化和高可用性。

**设计细节**：

- 使用 Redis 的有序集合（`ZSET`）和哈希（`HASH`）数据结构存储订单簿和订单详情。
- 利用 Redis 的单线程模型和 Lua 脚本，保证数据操作的原子性。
- 采用 Redis 的主从复制和哨兵模式，确保数据的高可用性。

---

## 4. 挂单和吃单模块设计细节

### 4.1 订单数据结构

**订单基本结构**：

```go
type Order struct {
    ID        string    // 订单ID
    Side      string    // 买卖方向：BUY 或 SELL
    Price     float64   // 价格（限价单）
    Quantity  float64   // 数量
    Timestamp int64     // 时间戳
}
```

### 4.2 限价单处理

**处理流程**：

1. **接收订单**：接收并验证限价单的订单信息。
2. **存储订单详情**：将订单信息以 JSON 格式存储在 Redis 的哈希表中，键名为 `order:{订单ID}`。
3. **添加到订单簿**：根据买卖方向，将订单添加到相应的订单簿有序集合中：
   - **买单簿**：`orderbook:buy`，`score = -price`（负价格，使价格从高到低排序）。
   - **卖单簿**：`orderbook:sell`，`score = price`（价格从低到高排序）。

**原子性操作**：

- 使用 Lua 脚本将订单详情的存储和订单簿的更新作为一个原子操作，避免数据不一致。

### 4.3 市价单处理

**处理流程**：

1. **接收订单**：接收并验证市价单的订单信息。
2. **订单匹配**：从对手方的订单簿中，按价格优先的原则，匹配最佳对手单。
3. **执行交易**：
   - 计算交易数量（取订单数量和对手单数量的最小值）。
   - 更新订单和对手单的剩余数量。
   - 如果对手单完成，移除其订单详情和订单簿记录。
4. **记录交易**：将交易信息存储在 Redis 中，以供后续查询和统计。

**原子性操作**：

- 将整个匹配过程封装在 Lua 脚本中，确保匹配和更新操作的原子性。

### 4.4 Lua 脚本的使用

**优势**：

- **原子性**：Lua 脚本在 Redis 中执行，确保整个操作的原子性，避免并发问题。
- **性能**：减少了网络通信，提升了系统性能。
- **可维护性**：将复杂的业务逻辑集中在脚本中，便于维护和更新。

**关键逻辑**：

- **获取最佳对手单**：根据订单方向，从对手方的订单簿中获取价格最优的订单。
- **处理交易**：更新订单数量，记录交易信息。
- **更新订单簿**：在对手单完成时，及时从订单簿和订单详情中移除。

---

## 5. 数据处理与存储方案

### 5.1 Redis 数据结构

- **有序集合（Sorted Set，`ZSET`）**：用于存储订单簿，支持按价格排序和高效查询。
- **哈希（Hash，`HASH`）**：用于存储订单详情，包含订单的全部信息。
- **列表（List）或流（Stream）**：用于存储交易记录，方便后续的查询和分析。

### 5.2 订单簿的存储

- **买单簿（`orderbook:buy`）**：
  - **成员**：订单ID。
  - **分数（`score`）**：`-price`（负价格），实现价格从高到低排序。
- **卖单簿（`orderbook:sell`）**：
  - **成员**：订单ID。
  - **分数（`score`）**：`price`，实现价格从低到高排序。

### 5.3 订单详情的存储

- **键名**：`order:{订单ID}`。
- **数据结构**：`HASH`，字段为 `data`，值为订单信息的 JSON 字符串。

### 5.4 交易记录的存储

- **方案一**：使用 `LIST`，键名为 `trades`，每个交易记录作为列表的一个元素，存储交易的 JSON 字符串。
- **方案二**：使用 `STREAM`，便于实时数据的消费和处理。

---

## 6. 高并发处理方法

### 6.1 原子性操作

- **Lua 脚本**：将多步操作封装在 Lua 脚本中，确保整个过程的原子性。
- **单线程模型**：Redis 的单线程模型天然避免了数据竞争问题。

### 6.2 Lua 脚本优化

- **函数封装**：将重复的逻辑封装成 Lua 函数，提升代码可读性和可维护性。
- **错误处理**：在 Lua 脚本中添加错误检查，及时捕获和处理异常情况。
- **返回结果**：在脚本末尾返回执行结果，便于在客户端进行处理。

### 6.3 并发请求的处理

- **异步处理**：在订单接收模块中，使用 Goroutine 异步处理订单请求，避免阻塞。
- **连接池**：`go-redis` 客户端默认使用连接池，支持高并发的连接请求。
- **限流和熔断**：在必要时加入限流策略，防止系统过载。

---

## 7. 使用案例

### 7.1 限价单下单示例

**请求示例**：

```bash
curl -X POST http://localhost:8080/v1/orders \
    -H 'Content-Type: application/json' \
    -d '{
        "id": "order1001",
        "side": "BUY",
        "order_type": "LIMIT",
        "price": 100.5,
        "quantity": 10
    }'
```

**处理流程**：

1. 订单接收模块接收请求，验证订单数据。
2. 调用 `addLimitOrder` 函数，使用 Lua 脚本将订单详情和订单簿更新作为一个原子操作执行。
3. 订单成功添加到买单簿，等待匹配。

### 7.2 市价单下单示例

**请求示例**：

```bash
curl -X POST http://localhost:8080/v1/orders \
    -H 'Content-Type: application/json' \
    -d '{
        "id": "order1002",
        "side": "SELL",
        "order_type": "MARKET",
        "quantity": 5
    }'
```

**处理流程**：

1. 订单接收模块接收请求，验证订单数据。
2. 调用 `matchMarketOrder` 函数，使用 Lua 脚本执行订单匹配逻辑。
3. Lua 脚本在 Redis 中执行，匹配最佳对手单，完成交易。

### 7.3 系统测试与验证

**测试内容**：

- **订单的正确存储**：验证订单详情和订单簿的存储是否正确。
- **交易的正确执行**：验证交易记录是否正确生成，订单数量是否正确更新。
- **高并发下的稳定性**：使用压力测试工具模拟高并发请求，观察系统的性能和稳定性。

**测试方法**：

- 使用单元测试框架编写测试用例，覆盖不同的订单类型和场景。
- 使用 `redis-cli` 或 Redis 可视化工具查看数据的变化。
- 监控系统资源的使用情况，评估性能瓶颈。
